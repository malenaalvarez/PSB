# -*- coding: utf-8 -*-
"""ProcesamientoFinal_SmartSleep.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1oysH6Ay0-mr1UOvXvuGYLzoEVZfDodPW

#Firebase: Recibo datos de la nube
"""

!pip install firebase_admin
!pip install requests
!pip install pykalman

import firebase_admin
from firebase_admin import credentials
from firebase_admin import firestore
from firebase_admin import firestore_async

import numpy as np
import numpy.ma as ma
import matplotlib.pyplot as plt
import scipy
from scipy import signal as sig
from scipy.signal import find_peaks
from scipy.signal import savgol_filter
from datetime import datetime
from matplotlib.lines import segment_hits
from pykalman import KalmanFilter

!pip install matplotlib==3.1.3

Certificado = {
  "type": "service_account",
  "project_id": "smartsleep-f2587",
  "private_key_id": "f1e8a1bd2f7cad4e256b365ad8b91fca00500b70",
  "private_key": "-----BEGIN PRIVATE KEY-----\nMIIEvAIBADANBgkqhkiG9w0BAQEFAASCBKYwggSiAgEAAoIBAQC3lS0hNyJvA75z\nyVg7rSObe9xUlDbn1D7Tmw1eNI3akE9Knl86tny0t0rh3AOuPLJ6IojYgbAzNeIk\ng80paeuKbVKf41/SjEvryx7NjTC8OaeIMctVGl3aWmzLI4XK9RZfE5gLsX9mrs9G\nqDmXPkIbVrjFMYFnhzDhR9ahRaIg8IVgUF+3DCO/fZATzjV+daBjGUSGygP/ymUY\nSRazCzHT14Y++KRJZ+8/Z0MN6zuRruJzNaxp9dEdOcNoUR9bCRVMQzDWaYK9oFOD\n098YVFsXiWbSfYDqWAR15AY9CYi/xeABTHT2cSKKs4wAYdgEamaFZXkW2xADP/U9\nakCAONl9AgMBAAECggEAFeGyiOB8+rV8CGoJ2ccX1OsNBonKB5TtTiSPkdh6xf/o\na5D38dQZhiLIyqYCTEzQyyz9mazPlzMHeum41QRaflvsesFLxRlS3U6PI9n94pmO\npfWlckXbxPB9QjNAOcI/weJgf5hPAqq4awgXITdbAs4x5NMzROdAxMFezEcz/W/q\nCc7F1mQGdSscLSY7o8Ar+a2G6CdQ1hZRZenvh/su1b6lGV1uWetdd3vDVb4J4jq2\nzIF7kPQmlAI1/XO9IFFqrVoHW+MXlgq3jBfKmXvPXexeBA2KKf/P4pKKxszaZei0\nbd6MjvqyCfUzrrw71O+bzfa5FC/AuPlnG4kI4cAI0QKBgQDfc1YuhLagF9P6zhzU\nyLomyKn4Y+ryAa6Fgd2zzuejYM/jEkJpGlqdyClOOqHcmYY88c5zKLVzR9yBPoeK\newYq6OS9iRqc7VixojRjEBAKMAtbLWKnKOXjxsVsqpCWXbGNUWTwpn6x/DeDVNb+\nBwfbHW5/HBJjRC6bmzQbI7XK2QKBgQDSUyJqUC14vEYf497wI0/1WyKbkfIHgjmU\n9StZ6hBK2+r7tVrBxIkJeGGq6FBpsYgP0+Gw5FGaienJIVMftmwMhypzTgOvt/xV\n1vX/LXddFn8UbjWq49+wXHQ9E+saLSYfpFpWKwmG71np1WD7m8Zgjdk3ynuyJXXc\nGg4E5CR1RQKBgEoCvrnbtU2jds/ssvn7nkS4VCv0lF4iFnccA53J20lvCIxSgPKl\nCvyVzrCdlP0nUKIhCVt1UVxkofGhD23bv7g4uYLZxZnSt3zml+lz6YwmS6yghLuP\nPU3LiZqriAZ19Bg1rHRVAUPcoVp7oFY1Z/G4dt/dIW4FqFZb+s8+bblJAoGAW/Hv\n9535YvCbj1FkooItcEtZA713mwS4+396ZiJG4RLm1QbhGBg8+CDiQX6xuKLdol20\nKkqFyhNEWqLw3co3zfpA+os+XVEHRNdmTxmnNtCg2WOcnopjvYuNXS4Z9yWJpweI\nXmcOESkNm4Wmkhf1Tzxzm0ovbR+nOINDYawCrCkCgYBM1pJYPTsD9t9bsqaIHurv\nBUzgNujUBDCRgWAuU/DCVZ5xINZDCClD8W8Lad1fI3qrZ8GUpe0JPXIAQKHY3U2x\n8kswtbchBNkX+DzHsVLoRqEluen/4CGuW32kfe/enhbmGK0kKKG5XElyFkv1CCMf\nXsFg0OD9RokCxfwjSK6TJQ==\n-----END PRIVATE KEY-----\n",
  "client_email": "firebase-adminsdk-a0sji@smartsleep-f2587.iam.gserviceaccount.com",
  "client_id": "114590036323489485890",
  "auth_uri": "https://accounts.google.com/o/oauth2/auth",
  "token_uri": "https://oauth2.googleapis.com/token",
  "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
  "client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/firebase-adminsdk-a0sji%40smartsleep-f2587.iam.gserviceaccount.com"

  }

if not firebase_admin._apps:
  cd = credentials.Certificate(Certificado)
  firebase_admin.initialize_app(cd)

db = firestore.client()
docs = db.collection('datos_crudos').order_by("Timestamp", direction= firestore.Query.ASCENDING).stream() #poner nombre de la collecion de datos crudos

diccionario = list()

for doc in docs:
    item = doc.to_dict()
    diccionario.append(item)

red = np.zeros(len(diccionario))
ir = np.zeros(len(diccionario))
x = np.zeros(len(diccionario))
y = np.zeros(len(diccionario))
z = np.zeros(len(diccionario))

i = 0

for muestras in (diccionario) :
  if 'Rojo:' in muestras.keys():
    i +=1
  else:
    red[i] = muestras["Rojo"]
    ir[i] = muestras["IR"]
    x[i] = muestras["Eje X"]
    y[i] = muestras["Eje Y"]
    z[i] = muestras["Eje Z"]
    i+=1

print(len(red))

"""#Procesamiento de la señal

##Señal del Acelerometro
"""

fs1=5.8
L=len(x)

t1=np.linspace(0,L/(fs1*60),L)

plt.figure(figsize=[25,7])
plt.plot(t1, x)
plt.title("Eje X del Acelerometro")
plt.xlabel("tiempo[minutos]")


plt.figure(figsize=[25,7])
plt.plot(t1, y,label="eje y")

plt.figure(figsize=[25,7])
plt.plot(t1, z,label="eje z")

plt.show()

b1, a1 = sig.butter (1,[0.03,0.8], 'bandpass')
x_filtrado = sig.filtfilt(b1,a1, x)

b2, a2 = sig.butter (1,[0.03,0.8], 'bandpass')
y_filtrado = sig.filtfilt(b2,a2, y)

b3, a3 = sig.butter (1,[0.03,0.8], 'bandpass')
z_filtrado = sig.filtfilt(b3,a3, z)

plt.figure(figsize=[25,7])
plt.plot(t1, x_filtrado,label="eje x")


plt.figure(figsize=[25,7])
plt.plot(t1, y_filtrado,label="eje y")

plt.figure(figsize=[25,7])
plt.plot(t1, z_filtrado,label="eje z")

plt.show()

D=np.zeros(np.shape(x)[0])

for i in range(0, len(x)):
  D[i]= (np.abs(x_filtrado[i]-x_filtrado[i-1])+np.abs(y_filtrado[i]-y_filtrado[i-1])+np.abs(z_filtrado[i]-z_filtrado[i-1]))*(fs1)

D = D/60

plt.figure(figsize=[25,7])
plt.plot(t1, D,label="D")

umbral= np.mean(D)

movimientos=[]
no_movimientos=[]

cont =0

for j in range(len(D)):
  if D[j]>=umbral:
    if j not in movimientos: 
      movimientos.append(j) #voy a apendear a movimientos el segundo en el que se registro un movimiento
  elif D[j]<umbral:
    if (j) not in no_movimientos:
      no_movimientos.append(j)

mins2= 10*fs1 #voy a contar cuantos movimientos registre en ventanas de 30 segundos 
cont=0
lista_movimientos1=[] #guarda la cantidad de movimientos que hay en cada 1min, cada valor representa la cantidad de movimientos por minuto

for mins in range(0,len(D),int(mins2)+1):
  cont=0
  for k in range(len(movimientos)):
    if(mins<=movimientos[k]<mins2+mins):
      cont+=1
  lista_movimientos1.append(cont)

media_movimiento= np.mean(lista_movimientos1)
desvio_movimiento= np.std(lista_movimientos1)

LS=0
DS=0
AW=0

for i in range(len(lista_movimientos1)):
  if lista_movimientos1[i] >(2*media_movimiento):
    AW+=1
  elif lista_movimientos1[i]>(media_movimiento):
    LS+=1
  else:
    DS+=1

print("El paciente durmio",np.round(LS/6,1),"minutos de sueño ligero")
print("El paciente durmio",np.round(DS/6,1),"minutos de sueño profundo")
print("El paciente estuvo despierto",np.round(AW/6,1),"minutos")

tiempo_total_sueño= np.round(L/(fs1*60),2)

LS_porcentaje =np.round((LS/(6*tiempo_total_sueño))*(100),2)
DS_porcentaje = np.round((DS/(6*tiempo_total_sueño))*(100),2)
AW_porcentaje = np.round((AW/(6*tiempo_total_sueño))*(100),2)

print("Tiempo total de sueño:", tiempo_total_sueño, "minutos")

print(LS_porcentaje+AW_porcentaje+DS_porcentaje)

np.set_printoptions(precision=5, suppress=True)

plt.figure(figsize=[25,7])
plt.plot(t1, D,label="eje x")

plt.show()

"""###Movement Intensity"""

def movement_intensity(x,y,z,IPI):
  MI_x=0
  MI_y=0
  MI_z=0

  MovementI=[]

  mean_x= np.mean(x)
  mean_y =np.mean(y)
  mean_z= np.mean(z)

  for i in range(len(IPI)):
    MI_x=((x[IPI[i]]-mean_x)**2)
    MI_y=(y[IPI[i]]-mean_y)**2
    MI_z=((z[IPI[i]]-mean_z)**2)
    MI_value=MI_x + MI_y + MI_z
    MovementI.append(MI_value)

  umbral = np.mean(MovementI)
  IPI_nueva=[]

  for k in range(0,len(IPI)):
    if MovementI[k]<umbral:
      IPI_nueva.append(IPI[k])
   

  return IPI_nueva, umbral

"""##Señal del fotopletismograma (PPG/RED)"""

def limpieza_ppg(PPG,prominencia):
  L=len(PPG)
  mean_red= np.mean(PPG)
  std_red= np.std(PPG)

  PPG_filtered = np.zeros((np.shape(PPG)))

  for i in range (0,len(PPG)):
    PPG_filtered[i]=(PPG[i]-mean_red)/std_red # Z score: restar a cada x la media y dividirlo por el desvio estandar

  picos_PPG,peaks_height= find_peaks(PPG_filtered,prominence=prominencia,width=1/fs1) #peaks te devuelve la posicion en el eje x

  picos_PPG_tiempo=(picos_PPG/fs1)

  intervalos = np.zeros(len(picos_PPG_tiempo)-1) #te devuelve un vector con el tiempo entre cada pico
  for i in range (len(intervalos)):
    intervalos[i]=picos_PPG_tiempo[i+1]-picos_PPG_tiempo[i]

  intervalos_muestras = []
  for i in range (len(picos_PPG)-1):
    intervalos_muestras.append(picos_PPG[i+1]-picos_PPG[i])

  return PPG_filtered, picos_PPG, intervalos, intervalos_muestras

PPG_red = red
PPG_ir = ir

L=len(PPG_red)
t=np.linspace(0,L/(fs1*60),L)

PPG_red_filtered, picos_PPG_tiempo_red, intervalos_red, intervalos_muestras_red = limpieza_ppg(PPG_red,0.32)
PPG_ir_filtered, picos_PPG_tiempo_ir, intervalos_ir, intervalos_muestras_ir = limpieza_ppg(PPG_ir,0.1)

plt.figure(figsize=[25,7])
plt.plot(t,PPG_red)
plt.title("Señal PPG RED original")

plt.figure(figsize=[25,7])
plt.plot(t,PPG_red_filtered)
plt.plot(t[picos_PPG_tiempo_red], PPG_red_filtered[picos_PPG_tiempo_red],"x")
plt.title("PPG con intervalos RR")
plt.xlim(2,3)
plt.ylim(-2,2.5)
plt.show()

plt.figure(figsize=[25,7])
plt.plot(t,PPG_ir_filtered)
plt.plot(t[picos_PPG_tiempo_ir], PPG_ir_filtered[picos_PPG_tiempo_ir],"x")
plt.title("PPG IR filtrada")
plt.show()

IPI_filtrados, umbral= movement_intensity(x_filtrado,y_filtrado,z_filtrado,intervalos_muestras_red)
n = np.linspace(0,len(intervalos_red),len(intervalos_red))
n2 = np.linspace(0,len(IPI_filtrados),len(IPI_filtrados))

for i in range(len(IPI_filtrados)):
  IPI_filtrados[i] = IPI_filtrados[i]/fs1

plt.figure(figsize = (30,10))
plt.title(f'Señal de HRV vieja vs nueva')
plt.plot(n, intervalos_red, label='HRV original')
plt.plot(n2,IPI_filtrados, label='HRV sin intervalos con mucho MI')
#plt.axhline(y=umbral, color = "red", linewidth = 1, linestyle = "dashed",label='umbral superior') #graficamos el umbral superior
plt.xlabel('Numero de intervalo')
plt.ylabel('Intervalos IPI [s]')
plt.legend()
plt.show()

def ectopicos(IPIs):
  #Defino los umbrales
  upper_threshold = (np.mean(IPIs)*1000 + 300) 
  lower_threshold = (np.mean(IPIs)*1000 - 300)

  #Detección de outliers
  cont = 0
  removed_beats = []
  IPIs_nuevos = []

  while cont < len(IPIs):
      if (IPIs[cont]*1000 < upper_threshold) and (IPIs[cont]*1000 > lower_threshold): #Intervalos correctos
          IPIs_nuevos.append(IPIs[cont])   
          cont += 1
      else:   #Outliers
          removed_beats.append(IPIs[cont])
          cont += 1

  return IPIs_nuevos, upper_threshold,lower_threshold

IPIs_final, umbral_sup, umbral_inf = ectopicos(IPI_filtrados)
n3 = np.linspace(0,len(IPIs_final),len(IPIs_final))

plt.figure(figsize = (30,10))
plt.title(f'Señal de HRV')
plt.plot(n2, IPI_filtrados, label='HRV sin intervalos con MI')
plt.plot(n3, IPIs_final, label='HRV sin ectopicos')
plt.axhline(y=umbral_sup/1000, color = "red", linewidth = 1, linestyle = "dashed",label='umbral superior') #graficamos el umbral superior
plt.axhline(y=umbral_inf/1000, color = "red", linewidth = 1, linestyle = "dashed",label='umbral inferior') #graficamos el umbral inferior
plt.xlabel('Numero de intervalo')
plt.ylabel('Intervalos IPI [s]')
plt.ylim(0,3)
plt.legend()
plt.show()

"""###Detección de Taquicardia y Bradicardia"""

def taqui_bradi(intervalos_red):  
  contador_tiempo_bradi = 0
  contador_tiempo_taqui = 0
  sum_taqui = 0
  sum_bradi = 0
  taquicardias=[]
  bradicardias=[]

  #Chequeo ibi promedio para poner condicion de bradi y taqui
  ibi_prom = np.mean(intervalos_red)
  fc_prom = 60/ibi_prom
  
  if np.isnan(fc_prom):
    fc_prom=0

  print("IBI promedio:",np.round(ibi_prom,2), "\nFrecuencia cardiaca promedio:", np.round(fc_prom,2) )

  for i in range (0, len(intervalos_red)):

    #Taquicardia
    if intervalos_red[i]*1000<600:    #Condicion de taquicardia en ms (FC = 100 lpm)
      sum_taqui += (intervalos_red[i])
      if sum_taqui > 120:     #Taquicardia durante 30 secs seguidos, pongo ahora 2 minutos
        contador_tiempo_taqui += sum_taqui
        taquicardias.append(sum_taqui/60)
    else: 
      sum_taqui = 0 
      
    #Bradicardia
    if intervalos_red[i]*1000>1200:    #Condicion de bradicardia en ms (FC = 50 lpm )
      sum_bradi += (intervalos_red[i])
      if sum_bradi > 120:     #Bradicardia durante 30 secs seguidos, pongo ahora 2 minutos
        contador_tiempo_bradi += sum_bradi
        bradicardias.append(sum_bradi/60)
    else: 
      sum_bradi = 0 


  #Contadores de segundos a min
  contador_tiempo_taqui/=60
  contador_tiempo_bradi/=60

  print("\nCantidad de episodios de taquicardia:",len(taquicardias),"\nCantidad de episodios de bradicardias:",len(bradicardias))
  print("\nTiempo en taquicardia:", np.round(float(contador_tiempo_taqui),3),"min", "\nTiempo en bradicardia:",np.round(float(contador_tiempo_bradi),3),"min")

  return contador_tiempo_taqui, contador_tiempo_bradi, fc_prom, ibi_prom

t_taqui, t_bradi, fc, ipi = taqui_bradi(IPIs_final)

"""###Detección de Fibrilación Auricular y Contracción Ventricular Prematura

Se utiliza la curva de variabilidad de la frecuencia cardíaca (HRV) para detectar cambios abruptos en la frecuencia cardíaca. 
Luego, establecimos la condicion de que, si el intervalo R-R (que es
vinculado a HRV) cambia repentinamente con más de 50 ms
por encima del umbral medio, se lo clasifica como “ausencia de un latido” y luego será reconocido por el sistema como un posible
fibrilación auricular (FA). Una contracción ventricular prematura (PVC) ocurre cuando se detecta un latido cardíaco "extra".
Cuando la curva HRV cae por debajo del umbral promedio
con más de 50 ms, se detecta un posible PVC,
"""

def AF_PVC(IPIs): 
  n = np.linspace(0,len(IPIs),len(IPIs))
  ibi_prom_nuevo = np.mean(IPIs)
  umbral = ibi_prom_nuevo
  AF = []
  PVC = []  
  cont_AF = 0
  cont_PVC = 0

  for i in range(len(IPIs)):
    if IPIs[i]*1000 > (umbral*1000 + 150):
      AF.append(IPIs[i])
      cont_AF += 1
    if IPIs[i]*1000 < (umbral*1000 - 150):
      PVC.append(IPIs[i])
      cont_PVC += 1

  print("AF:", cont_AF, "\nPVC:",cont_PVC)
  
  return AF, PVC, cont_AF, cont_PVC

IPIs_AF, IPIs_PVC, n_AF, n_PVC = AF_PVC(IPIs_final)

"""## BR

https://drive.google.com/file/d/1JdJqVzFFd68BWvEtRN6PFMa5VDRyAXqA/view?usp=sharing

### Filtro pasabanda
https://drive.google.com/file/d/16W1_H4Dz1S7lqCoix7IeQg4qBqOZ2qdB/view?usp=sharing
"""

b, a = sig.butter(1, [0.05,0.1], 'bandpass')   #filtro orden 1 
PPG_filtrado_br = sig.filtfilt(b, a, PPG_red)  #data es la señal a filtrar

plt.figure(figsize=[25,7])
plt.plot(t,PPG_filtrado_br)
plt.title("Señal PPG [Red] filtrado")

plt.show()

"""### Picos de la señal """

prominencia= 0.5 #tambien puede ser 0.1, 0.5 y 0.9 para obtener el RQI

#plt.figure(figsize=[25,7])
#plt.title("Señal PPG con picos")
#plt.plot(t,PPG_filtrado_br)
#plt.axhline(y=prominencia, color = "red")

#plt.plot(t[valores_positivos], PPG_filtrado_br[valores_positivos], "x")
#plt.plot(t[picos_PPG], PPG_filtrado[picos_PPG_low], "x")
#plt.xlim(400,410)
#plt.show()

def graficar_picos(PPG_filtrado,prominencia,ancho):

  t= np.linspace(0,len(PPG_filtrado)/fs1,len(PPG_filtrado))
  #Positivos
  picos_PPG,peaks_height= find_peaks(PPG_filtrado,prominence= prominencia,width = ancho) #peaks te devuelve la posicion en el eje x
  #Negativos
  picos_PPG_low,peaks_height_low= find_peaks(-PPG_filtrado,prominence = prominencia, width = ancho)

  picos_PPG_tiempo=(picos_PPG/fs1) #segundos donde se dan los picos de PPG

  intervalos = np.zeros(len(picos_PPG_tiempo)) #te devuelve un vector con el tiempo entre cada pico

  for i in range (len(intervalos)-1):
    intervalos[i]=picos_PPG_tiempo[i+1]-picos_PPG_tiempo[i]

  return picos_PPG, picos_PPG_low

#picos1, picos2 =graficar_picos(PPG_filtrado_br, prominencia, 0)

"""### Analisis por Ventanas de 64s"""

def ventana(sig,seg,fs1):
  C4_filt=sig
  lista_epoca = []
  lista_tiempos = []
  L=len(sig)
  t=np.linspace(0,L/fs1,L)

  for i in range (0 , int(len(sig)/seg)):
    epocho = i
    epochfi = i + 1 

    t0 = epocho*seg
    tf = epochfi*seg

    t_0 = int(t0*fs1)
    t_f = int(tf*fs1)

    C4_cut = C4_filt[t_0:t_f]
    if len(C4_cut) == 0:
      return lista_tiempos,lista_epoca
    
    t = np.linspace(t0, tf,C4_cut.shape[0])
    lista_tiempos.append(t)
    lista_epoca.append(C4_cut)

  return lista_tiempos,lista_epoca

"""### Ventanas de 64s"""

tiempos64,epocas64 = ventana(PPG_filtrado_br,64,fs1)
plt.plot(tiempos64[0],epocas64[0])
plt.show()

"""### Modulaciones por Epoca"""

def modulaciones_epocas(tiempos,epocas,fs1,umbral):
  RIFV = dict()
  RIAV = dict()
  RIIV = dict()

  for i in range(len(epocas)):
    picos_PPG = 0
    peaks_height = 0
    picos_PPG_low = 0
    peaks_height_low = 0
    picos_PPG_tiempo = 0
    curr_epoca = epocas[i]

    #Positivos
    picos_PPG,peaks_height= find_peaks(epocas[i],prominence=umbral)#peaks te devuelve la posicion en el eje x
    
    #Negativos
    picos_PPG_low,peaks_height_low= find_peaks(-epocas[i],prominence=umbral)

    picos_PPG_tiempo=(picos_PPG/fs1) #segundos donde se dan los picos de PPG

    ########## RIFV ###################
    intervalos = np.zeros(len(picos_PPG_tiempo)) #te devuelve un vector con el tiempo entre cada pico
    

    for j in range (len(intervalos)-1):
      intervalos[j]=picos_PPG_tiempo[j+1]-picos_PPG_tiempo[j]
      
    RIFV[i] = intervalos
    

    ########## RIAV ###################
    alturas = np.zeros(len(picos_PPG))

    for k in range (len(picos_PPG)-1):
      alturas[k]=(peaks_height['prominences'][k])+(peaks_height_low['prominences'][k])#RIAV --> distancia en "y" entre pico y pico
    
    RIAV[i] = alturas
     
    ########## RIIV ###################
    #RIIV --> is the variation of perfusion baseline
    perfusion = curr_epoca[picos_PPG]
    
    RIIV[i] = perfusion
    
    
  return RIFV,RIAV,RIIV

RIFV,RIAV,RIIV =  modulaciones_epocas(tiempos64,epocas64,fs1,prominencia)

"""### RQI 

https://www.ncbi.nlm.nih.gov/pmc/articles/PMC8031461/pdf/pone.0249843.pdf

We calculate the DCV for peak heights, trough depths, peak-to-peak distances and trough-to-trough distances as follows

$DCV = 1 - sd/mean$


RQI = max(Sum(DVCi)/3)

Lo hago por cada ventana y elijo la ventana con el valor mas alto
"""

def RQI_max(RIFV,RIAV,RIIV):
  l = len(RIFV.keys())
  RQI = []

  for k in range((l)):

    DCV_RIFV =0
    DCV_RIAV =0
    DCV_RIIV =0
    
    DCV_RIFV  = 1 - (np.std(RIFV[k]) / np.mean(RIFV[k]))
    
    DCV_RIAV  = 1 - (np.std(RIAV[k]) / np.mean(RIAV[k]))
    
    DCV_RIIV  = 1 - (np.std(RIIV[k]) / np.mean(RIIV[k]))
    
    resultado = (DCV_RIFV + DCV_RIAV + DCV_RIIV)/3

    if np.isnan(resultado) == True:
      RQI.append(0)
    else:
      RQI.append((DCV_RIFV + DCV_RIAV + DCV_RIIV)/3)

    
  RQI_max = np.max(RQI)

  index = RQI.index(RQI_max)

  return index,RQI_max,RQI

index,rqi_max,rqis = RQI_max(RIFV,RIAV,RIIV)

print("El mayor RQI lo tiene la epoca",index, "con un valor de", rqi_max)

"""### Algoritmo de Kalman Smoother

"""

kf = KalmanFilter(initial_state_mean=0, n_dim_obs=1)
measurements = epocas64[index]
#(filtered_state_means, filtered_state_covariances) = kf.filter(measurements)
(smoothed_state_means, smoothed_state_covariances) = kf.smooth(measurements)

shape = len(smoothed_state_means)
signal_br = smoothed_state_means.reshape(shape)


plt.figure(figsize=[30,10])
plt.plot(tiempos64[index],epocas64[index], color = "blue")
plt.plot(tiempos64[index],signal_br,color ="green")
#plt.xlim(140,150)
#plt.plot(tiempos64[2],filtered_state_means,color ="red")
plt.show()

"""### Frecuencia Respiratoria 

The time difference between two consecutive maxima corresponds to one respiratory cycle (ttot in seconds) and its inverse (multiplied by 60) is the instantaneous BR (in bpm).

PPG signal with threshold coefficient tuned
at 0.7. 

Usamos 0.75 por posibles errores en el algoritmo

Una frecuencia respiratoria normal para un adulto en reposo es de 8 a 20 respiraciones por minuto
"""

def BR(tiempos,epoca,fs1):

  max_epoca = np.max(epoca)

  picos_PPG,peaks_height= find_peaks(epoca,prominence = 0.7) #Umbral que usa el paper
  picos_PPG_tiempo=(picos_PPG/fs1) #segundos donde se dan los picos de PPG
  distancia = np.zeros(len(picos_PPG_tiempo)) #te devuelve un vector con el tiempo entre cada pico

  for i in range (len(distancia)-1):
    distancia[i]=picos_PPG_tiempo[i+1]-picos_PPG_tiempo[i]

  #### Calcualo de BR ####

  ciclo_br = np.max(distancia)
 
  if ciclo_br == 0:
    f_br = 0

  else:
    f_br = round((1/ciclo_br)*60)

  t=np.linspace(0,len(epoca)/(fs1*60),len(epoca))
  
  plt.figure(figsize=[20,7])
  plt.title("Señal PPG con picos")
  plt.plot(t,epoca)
  plt.plot(t[picos_PPG], epoca[picos_PPG], "x")

  plt.show()
  
  return f_br

f_br =BR(tiempos64[index],signal_br,fs1)
print("La frecuencia respiratoria es:",f_br) #bpm

"""## Spo2

### Calculo R
"""

b1, a1 = sig.butter (1,[0.03,0.065], 'bandpass')
PPG_red_Spo2 = sig.filtfilt(b1,a1, PPG_red_filtered)

b1, a1 = sig.butter (1,[0.03,0.065], 'bandpass')
PPG_ir_Spo2 = sig.filtfilt(b1,a1, PPG_ir_filtered)

PPG_red_Spo2=PPG_red_Spo2+ np.abs(np.min(PPG_red_Spo2))
PPG_ir_Spo2 = PPG_ir_Spo2 + np.abs(np.min(PPG_ir_Spo2))

mediaRed = np.mean(PPG_red_Spo2)
mediaIR = np.mean(PPG_ir_Spo2)

picosRed, picos_lowRed = graficar_picos(PPG_red_Spo2,0.25*mediaRed,1/fs1)
picosIR, picos_lowIR = graficar_picos(PPG_ir_Spo2,0.06*mediaIR,1/fs1)


picosRed = np.delete(picosRed,len(picosRed)-1)
picosIR = np.delete(picosIR,len(picosIR)-1)

plt.figure(figsize=[25,7])
plt.title(f"Señal PPG Red con picos")
plt.plot(t,PPG_red_Spo2)
plt.plot(t[picosRed], PPG_red_Spo2[picosRed], "x")
plt.plot(t[picos_lowRed], PPG_red_Spo2[picos_lowRed], "x")

plt.figure(figsize=[25,7])
plt.title(f"Señal PPG IR con picos")
plt.plot(t,PPG_ir_Spo2)
plt.plot(t[picosIR], PPG_ir_Spo2[picosIR], "x")
plt.plot(t[picos_lowIR], PPG_ir_Spo2[picos_lowIR], "x")

plt.show()

def listasPicos(red,ir):
  M= len(red)
  N= len(ir)
  maximo = max(M,N)
  largo = min(M,N)

  if maximo == M:
    for i in range(0,largo-1):
      if (np.abs(red[i]-ir[i])>= 9 and M>N):
        if (red[i]-ir[i] <=9):
          red =np.delete(red,i)
          M=len(red)
      
  if maximo ==N:
    for k in range(0,largo-1):
      if (np.abs(ir[k]-red[k])>= 9 and N>M):
        if (ir[k+1] - red[k] <=9):
          ir =np.delete(ir,k)
          N=len(ir)

  return red, ir

def calculoSpO2(PPG_red, PPG_ir,picosR, picosIr, picosR_low, picosIr_low):
  M= len(picosR)
  N= len(picosIr)
  O= len(picosR_low)
  P= len(picosIr_low)
  saturacion = 0
  largo = min(M,N,O,P)
  R = np.zeros(largo)
  amplitud_AC_ir = np.zeros(largo)
  amplitud_DC_ir = np.zeros(largo)
  amplitud_AC_red = np.zeros(largo)
  amplitud_DC_red = np.zeros(largo)

  media_DC_IR = np.mean(picosIr_low)
  media_DC_Red = np.mean(picosR_low)

  for i in range(largo):
    amplitud_AC_red[i] = PPG_red[picosR[i]] - PPG_red[picosR_low[i]]
    amplitud_AC_ir[i] = PPG_ir[picosIR[i]] -  PPG_ir[picosR_low[i]]
    #amplitud_DC_red[i] =  PPG_red[picosR_low[i]]
    #amplitud_DC_ir[i] = PPG_ir[picosR_low[i]]

    R[i] = (np.abs(amplitud_AC_red[i])*media_DC_IR)/(media_DC_Red*np.abs(amplitud_AC_ir[i]))
  
  list_spo2 = list()

  for i in range(len(R)):
    valor = 115 - 25*R[i] 

    if 88 < valor <= 100 :
      list_spo2.append(valor)

    saturacion = np.round(np.mean(list_spo2),2)

  return saturacion

#picosRed_n, picosIR_n = listasPicos(picosRed, picosIR)
#picosRed_low_n, picosIR_low_n = listasPicos(picos_lowRed, picos_lowIR)

SpO2 = calculoSpO2(PPG_red_Spo2,PPG_ir_Spo2,picosRed,
                   picosIR,picos_lowRed,picos_lowIR)

"""#Firebase: Envio los datos a la nube

"""

print(float(fc),float(f_br), SpO2, t_bradi, t_taqui,  float(n_AF), float(n_PVC), DS_porcentaje, LS_porcentaje,  AW_porcentaje, tiempo_total_sueño )

dt = datetime.now()
ts= datetime.timestamp(dt)

db = firestore.client()

db.collection('Resultados').add({"FC": float(fc), "FR": float(f_br), "SpO2": SpO2, "Bradicardia": t_bradi, "Taquicardia": t_taqui, "AF": float(n_AF), "PVC": float(n_PVC), "DS": DS_porcentaje, "LS": LS_porcentaje, "AW": AW_porcentaje, "Duracion": tiempo_total_sueño, "TS": ts})

def delete_collection(coll_ref, batch_size):
    docs = coll_ref.list_documents(page_size=batch_size)
    deleted = 0

    for doc in docs:
        #print(f'Deleting doc {doc.id} => {doc.get().to_dict()}')
        doc.delete()
        deleted = deleted + 1

    if deleted >= batch_size:
        return delete_collection(coll_ref, batch_size)

#delete_collection(db.collection('datos_crudos'),1)