# -*- coding: utf-8 -*-
"""FinalPSB_Alvarez_Teubal.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1l7dHCWyNC4J8CVe2a7NtmU7ym5Jdlcii
"""

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# 
# #ESTO NO VA , FUE DE PRUEBA
# '''
# apnea=[]
# for i in range (0, len(lista_eventos)):
#   if lista_eventos[i][0] == 'HA' or lista_eventos[i][0] == 'H' :
#     apnea.append(lista_eventos[i][1])
# '''
# 
# 
# '''  
# N = len(RR)
# for i in range(0, N):
#   if 0.7*media > RR[i][0] or RR[i][0] > 1.3*media:
#     lista_eliminar=[*range(RR[i][1],RR[i][1]+RR[i][0])]
#     senal= np.delete(senal,lista_eliminar)
#     duracion = RR[i][0]
#     #del RR[i]
#     for k in range(i,N-1):
#       RR[k][1]-= duracion
#     
#     N = len(RR)
# 
# for i in range(0, N):
# if RR[i][0] < (media-3*desvio) or RR[i][0] > (media+3*desvio):
#   lista_eliminar=[*range(RR[i][1],RR[i][1]+RR[i][0])]
#   senal= np.delete(senal,lista_eliminar)
# '''
# 
# 
# '''
# #CON EL MODELO AR 
# def lpc(y, m):
#     R = [y.dot(y)]
#     if R[0] == 0:
#         return [1] + [0] * (m-2) + [-1]
#     else:
#       # Calcula la autocorrelación R
#         for i in range(1, m + 1):
#             r = y[i:].dot(y[:-i])
#             R.append(r)
#         R = np.array(R)
#         A = np.array([1, -R[1] / R[0]])
#         P = R[0] + R[1] * A[1]
#         for k in range(1, m):
#             if (P == 0):
#                 P = 10e-17
#             ki = - A[:k+1].dot(R[k+1:0:-1]) / P
#             A = np.hstack([A,0])
#             A = A + ki * A[::-1]
#             P *= (1 - ki**2)
#         return A
# 
# L = 150000
# A = lpc(senal_ecg1, L)
# V = np.random.randn(len(senal_ecg1))
# y_a = sig.lfilter(np.ones(len(A)), A, V)
# nfft = len(senal_ecg1)
# S_a = np.var(V) / np.abs(1+fft(A,nfft))**2
# 
# plt.figure(figsize=(28,7))
# plt.plot(vector_frecuencias1,S_a[0:len(S_a)//2])
# plt.show()
# '''
# 
# '''
# RR_3 = np.array(RR_3)
# t = np.linspace(0, len(RR_3), len(RR_3))
# plt.figure(figsize=(29,8))
# plt.plot(t, RR_3[:,0])
# plt.show
# 
# NN_3 = np.array(NN_3)
# t = np.linspace(0, len(NN_3), len(NN_3))
# plt.figure(figsize=(29,8))
# plt.plot(t, NN_3[:,0])
# plt.show()
# '''
# 
# '''
# vector_frecuencias1 = np.linspace(0,fs/2, len(NN_1)//2)
# vector_frecuencias2 = np.linspace(0,fs/2, len(NN_2)//2)
# vector_frecuencias3 = np.linspace(0,fs/2, len(NN_3)//2)
# vector_frecuencias4 = np.linspace(0,fs/2, len(NN_4)//2)
# 
# plt.figure(figsize=(29,8))
# plt.plot(vector_frecuencias1, dep_1[0:len(dep_1)//2])
# #plt.xlim(0,0.4)
# plt.ylim(0,300)
# plt.figure(figsize=(29,8))
# plt.plot(vector_frecuencias2, dep_2[0:len(dep_2)//2])
# #plt.xlim(0,0.4)
# plt.ylim(0,500)
# plt.show()
# 
# #BUSCO VALORES DE VLF LF Y HF
# '''
# 
# '''
# 
# lomb_2=pyhrv.frequency_domain.lomb_psd(NN_2[:,0]//fs,NN_2[:,1]//fs)
# lomb_3=pyhrv.frequency_domain.lomb_psd(NN_3[:,0]//fs,NN_3[:,1]//fs)
# lomb_4=pyhrv.frequency_domain.lomb_psd(NN_4[:,0]//fs,NN_4[:,1]//fs)
# 
# abs1=lomb_1['lomb_abs']
# abs2=lomb_2['lomb_abs']
# abs3=lomb_3['lomb_abs']
# abs4=lomb_4['lomb_abs']
# 
# VLF_lomb_1,LF_lomb_1, HF_lomb_1=abs1
# VLF_lomb_2,LF_lomb_2, HF_lomb_2=abs2
# VLF_lomb_3,LF_lomb_3, HF_lomb_3=abs3
# VLF_lomb_4,LF_lomb_4, HF_lomb_4=abs4
# '''
# 
# '''
# ar_1 = pyhrv.frequency_domain.ar_psd(NN_1[:,0]//fs,NN_1[:,1]//fs)
# ar_2 = pyhrv.frequency_domain.ar_psd(NN_2[:,0]//fs,NN_2[:,1]//fs)
# ar_3 = pyhrv.frequency_domain.ar_psd(NN_3[:,0]//fs,NN_3[:,1]//fs)
# ar_4 = pyhrv.frequency_domain.ar_psd(NN_4[:,0]//fs,NN_4[:,1]//fs)
# 
# abs1 = ar_1['ar_abs']
# abs2 = ar_2['ar_abs']
# abs3 = ar_3['ar_abs']
# abs4 = ar_4['ar_abs']
# 
# VLF_ar_1,LF_ar_1, HF_ar_1=abs1
# VLF_ar_2,LF_ar_2, HF_ar_2=abs2
# VLF_ar_3,LF_ar_3, HF_ar_3=abs3
# VLF_ar_4,LF_ar_4, HF_ar_4=abs4
# '''
# 
# '''
# senal_eeg1 = signal1[:,2]
# senal_eeg2 = signal2[:,2]
# senal_eeg3 = signal3[:,2]
# senal_eeg4 = signal4[:,2]
# senal_eeg5 = signal5[:,2]
# senal_eeg6 = signal6[:,2]
# senal_eeg7 = signal7[:,2]
# senal_eeg8 = signal8[:,2]
# senal_eeg9 = signal9[:,2]
# senal_eeg10 = signal10[:,2]
# senal_eeg11 = signal11[:,2]
# senal_eeg12 = signal12[:,2]
# senal_eeg13 = signal13[:,2]
# senal_eeg14 = signal14[:,2]
# senal_eeg15 = signal15[:,2]
# senal_eeg16 = signal16[:,2]
# senal_eeg17 = signal17[:,2]
# senal_eeg18 = signal18[:,2]
# '''
# '''lista_frecuencias = np.zeros ((18,3))
# 
# lista_frecuencias[0,:] = estimadores_frecuencia (transformada1,lomb_1,ar_1)
# lista_frecuencias[1,:] = estimadores_frecuencia (transformada2,lomb_2,ar_2)
# lista_frecuencias[2,:] = estimadores_frecuencia (transformada3,lomb_3,ar_3)
# lista_frecuencias[3,:] = estimadores_frecuencia (transformada4,lomb_4,ar_4)
# lista_frecuencias[4,:] = estimadores_frecuencia (transformada5,lomb_5,ar_5)
# lista_frecuencias[5,:] = estimadores_frecuencia (transformada6,lomb_6,ar_6)
# lista_frecuencias[6,:] = estimadores_frecuencia (transformada7,lomb_7,ar_7)
# lista_frecuencias[7,:] = estimadores_frecuencia (transformada8,lomb_8,ar_8)
# lista_frecuencias[8,:] = estimadores_frecuencia (transformada9,lomb_9,ar_9)
# lista_frecuencias[9,:] = estimadores_frecuencia (transformada10,lomb_10,ar_10)
# lista_frecuencias[10,:] = estimadores_frecuencia (transformada11,lomb_11,ar_11)
# lista_frecuencias[11,:] = estimadores_frecuencia (transformada12,lomb_12,ar_12)
# lista_frecuencias[12,:] = estimadores_frecuencia (transformada13,lomb_13,ar_13)
# lista_frecuencias[13,:] = estimadores_frecuencia (transformada14,lomb_14,ar_14)
# lista_frecuencias[14,:] = estimadores_frecuencia (transformada15,lomb_15,ar_15)
# lista_frecuencias[15,:] = estimadores_frecuencia (transformada16,lomb_16,ar_16)
# lista_frecuencias[16,:] = estimadores_frecuencia (transformada17,lomb_17,ar_17)
# lista_frecuencias[17,:] = estimadores_frecuencia (transformada18,lomb_18,ar_18)
# '''
# 
# '''
# if lista_eventos[i][0] in ('HA','H','OA','CAA','CA', 'X', 'MT'):
#   num=lista_eventos[i][1]
#   # if i < len(senal):
#   #   lista_eliminar=[*range(num,num+7500,1)]
#   #   senal= np.delete(senal,lista_eliminar)
#   #   for k in range(i,len(lista_eventos)):
#   #     lista_eventos[k][1]-=7500
#   # elif i >= len(senal):
#   #   lista_eliminar=[*range(num,num+7499,1)]
#   #   senal= np.delete(senal,lista_eliminar)
#   #   for k in range(i,len(lista_eventos)):
#   #     lista_eventos[k][1]-=7499
#   lista_eliminar=[*range(num,num+7499,1)]
#   senal= np.delete(senal,lista_eliminar)
#   
#   for k in range(i,len(lista_eventos)):
#     lista_eventos[k][1]-=7499
# '''
# 
# # #CON EL PERIODOGRAMA DE LOMB
# 
# # def lomb (NN,fs):
# #   NN = np.array(NN)
# #   lomb= pyhrv.frequency_domain.lomb_psd(NN[:,0]//fs, NN[:,1]//fs, show =False, show_param=False)
# #   abs=lomb['lomb_abs']
# 
# #   return abs
# 
# # #Modelo AR
# 
# # def DEP_ar (NN, fs):
# #   NN = NN.array(NN)
# #   ar =  pyhrv.frequency_domain.ar_psd(NN[:,0]//fs, NN[:,1]//fs, show =False, show_param =False)
# #   abs = ar['ar_abs']
#   
# #   return abs  
# 
# '''
# lista_tiempo[0,:] = estimadores (NN_1)
# lista_tiempo[1,:] = estimadores (NN_2)
# lista_tiempo[2,:] = estimadores (NN_3)
# lista_tiempo[3,:] = estimadores (NN_4)
# lista_tiempo[4,:] = estimadores (NN_5)
# lista_tiempo[5,:] = estimadores (NN_6)
# lista_tiempo[6,:] = estimadores (NN_7)
# lista_tiempo[7,:] = estimadores (NN_8)
# lista_tiempo[8,:] = estimadores (NN_9)
# lista_tiempo[9,:] = estimadores (NN_10)
# lista_tiempo[10,:] = estimadores (NN_11)
# lista_tiempo[11,:] = estimadores (NN_12)
# lista_tiempo[12,:] = estimadores (NN_13)
# lista_tiempo[13,:] = estimadores (NN_14)
# lista_tiempo[14,:] = estimadores (NN_15)
# lista_tiempo[15,:] = estimadores (NN_16)
# lista_tiempo[16,:] = estimadores (NN_17)
# lista_tiempo[17,:] = estimadores (NN_18)
# '''
# 
# '''
# def estimadores_frecuencia(funcion):
# 
#   VLF = funcion[0]
#   LF = funcion[1]
#   HF = funcion [2]
# 
#   division = LF/HF
#   LFn = (LF*100)/(LF+HF-VLF)
#   HFn = (HF*100) / (LF + HF -VLF)
#   
#   lista_estimadores_f = [division, LFn, HFn]
# 
#   return lista_estimadores_f
# '''
# 
# '''
# lista_tf = [transformada1, transformada2, transformada3, transformada4, transformada5, transformada6, transformada7, transformada8, transformada9,transformada10, transformada11, transformada12, transformada13, transformada14, transformada15, transformada16, transformada17, transformada18]
# lista_lomb = [lomb_1, lomb_2, lomb_3, lomb_4, lomb_5, lomb_6, lomb_7, lomb_8, lomb_9,lomb_10, lomb_11, lomb_12, lomb_13, lomb_14, lomb_15, lomb_16, lomb_17, lomb_18]
# lista_ar = [ar_1, ar_2, ar_3, ar_4, ar_5, ar_6, ar_7, ar_8, ar_9,ar_10, ar_11, ar_12, ar_13, ar_14, ar_15, ar_16, ar_17, ar_18]
# '''

from google.colab import drive
drive.mount('/content/drive')

import numpy as np
import matplotlib as mpl
import matplotlib.pyplot as plt
from matplotlib.patches import Circle
import matplotlib.ticker as tck
import scipy as sp
import scipy.signal as sig
from scipy.linalg import toeplitz
from scipy import io
from scipy.fftpack import fft, ifft, fftfreq
import pandas as pd
from sklearn import datasets

!pip install wfdb
!pip install ishneholterlib

!pip install matplotlib==3.1.3

!pip install pyhrv

import wfdb
import pyhrv
import ishneholterlib
from wfdb import processing
import matplotlib as mpl
import matplotlib.pyplot as plt
from matplotlib.patches import Circle
import matplotlib.ticker as tck

#CARGO TODAS LAS SEÑALES DE ECG 
plt.ioff()
path1= '/content/drive/MyDrive/PSB/FINAL/slp01a'
signal1, fields1 = wfdb.rdsamp(path1,1)

path2= '/content/drive/MyDrive/PSB/FINAL/slp01b'
signal2, fields2 = wfdb.rdsamp(path2,1)

path3= '/content/drive/MyDrive/PSB/FINAL/slp02a'
signal3, fields3 = wfdb.rdsamp(path3,1)

path4= '/content/drive/MyDrive/PSB/FINAL/slp02b'
signal4, fields4 = wfdb.rdsamp(path4,1)

path5= '/content/drive/MyDrive/PSB/FINAL/slp03'
signal5, fields5 = wfdb.rdsamp(path5,1)

path6= '/content/drive/MyDrive/PSB/FINAL/slp04'
signal6, fields6 = wfdb.rdsamp(path6,1)

path7= '/content/drive/MyDrive/PSB/FINAL/slp14'
signal7, fields7 = wfdb.rdsamp(path7,1)

path8= '/content/drive/MyDrive/PSB/FINAL/slp16'
signal8, fields8 = wfdb.rdsamp(path8,1)

path9= '/content/drive/MyDrive/PSB/FINAL/slp32'
signal9, fields9 = wfdb.rdsamp(path9,1)

path10= '/content/drive/MyDrive/PSB/FINAL/slp37'
signal10, fields10 = wfdb.rdsamp(path10,1)

path11= '/content/drive/MyDrive/PSB/FINAL/slp41'
signal11, fields11 = wfdb.rdsamp(path11,1)

path12= '/content/drive/MyDrive/PSB/FINAL/slp45'
signal12, fields12 = wfdb.rdsamp(path12,1)

path13= '/content/drive/MyDrive/PSB/FINAL/slp48'
signal13, fields13 = wfdb.rdsamp(path13,1)

path14= '/content/drive/MyDrive/PSB/FINAL/slp59'
signal14, fields14 = wfdb.rdsamp(path14,1)

path15= '/content/drive/MyDrive/PSB/FINAL/slp60'
signal15, fields15 = wfdb.rdsamp(path15,1)

path16= '/content/drive/MyDrive/PSB/FINAL/slp61'
signal16, fields16 = wfdb.rdsamp(path16,1)

path17= '/content/drive/MyDrive/PSB/FINAL/slp66'
signal17, fields17 = wfdb.rdsamp(path17,1)

path18= '/content/drive/MyDrive/PSB/FINAL/slp67x'
signal18, fields18 = wfdb.rdsamp(path18,1)

senal_ecg1= signal1[:,0]
senal_ecg2=signal2[:,0]
senal_ecg3=signal3[:,0]
senal_ecg4=signal4[:,0]
senal_ecg5=signal5[:,0]
senal_ecg6=signal6[:,0]
senal_ecg7=signal7[:,0]
senal_ecg8=signal8[:,0]
senal_ecg9=signal9[:,0]
senal_ecg10=signal10[:,0]
senal_ecg11=signal11[:,0]
senal_ecg12=signal12[:,0]
senal_ecg13=signal13[:,0]
senal_ecg14=signal14[:,0]
senal_ecg15=signal15[:,0]
senal_ecg16=signal16[:,0]
senal_ecg17=signal17[:,0]
senal_ecg18=signal18[:,0]

fs= fields1['fs']

def estimadores(lista_intervalos):
  media=0
  desvio=0
  RMSSD=0
  N=len(lista_intervalos)

  for j in range(0, N):
    media+=lista_intervalos[j][0]
  media=media/N

  for i in range(0,N):
    desvio+=(lista_intervalos[i][0]-media)**2
  desvio=np.sqrt(desvio/N)

  for k in range(0,N-1):
    RMSSD+= (lista_intervalos[k+1][0]-lista_intervalos[k][0])**2
  RMSSD= np.sqrt(RMSSD/N)

  return media, desvio, RMSSD

def panytom(y,fs):
  
  x = np.asarray(y)

  fc1=5
  fc2=15
  orden=40

  #b3,a3=sig.iirfilter(95,[fc1,fc2],btype='bandpass',analog=False,ftype='butter',output = 'ba',fs=fmuestreo)
  h_coef=sig.firwin(orden+1,[fc1,fc2],fs=fs)
  senal2=sig.filtfilt(h_coef,1,x)

  #derivador
  derivada = 0
  Fs = fs
  Ts = 1/Fs
  aux = np.zeros(np.shape(senal2))
  SF=30 

  for i in range(SF,len(x)-(1+SF)):
    derivada = (senal2[i+SF] -senal2[i-SF])/(2*SF*Ts)
    aux[i]=derivada
    if i==SF:
      aux[SF]=derivada

  #elevo al cuadrado la señal
  aux2= aux*aux

  #integro la señal

  aux3=np.zeros(np.shape(aux2))
  aux3[0]=0
  M=8
  for k in range(1,len(aux2)-M):
    for p in range (k,k+M):
        Integral = aux3[p-1] + (aux2[p] + aux2[p-1])*(Ts)
    
    aux3[k]=Integral
  
  #umbral=(0.2)*np.max(aux3)
  picos,_= sig.find_peaks(aux3,distance=150)

  
  return picos

def procesamiento (path, senal, fs):
  anotaciones_sueno = wfdb.rdann(path,'st',1)
  anot=anotaciones_sueno.aux_note
  sam=anotaciones_sueno.sample
  cadena=0
  lista_eventos=[]
  lista_stages=[]
  eventos_n=[]
  senal_n=[]
  stages_n=[]

  for j in range (0, len(anot)):
    cadena= str(anot[j])
    if cadena[0] in ('1', '2', '3', '4', 'W', 'R'):
      lista_eventos.append([cadena[2:4],sam[j]])
      lista_stages.append(cadena[0:2])

  for i in range (0, len (lista_eventos)):
    if lista_eventos[i][0] not in ('OA','CAA','CA', 'X', 'MT'): #DEJAMOS LAS H Y HA
      eventos_n.append(lista_eventos[i])
      num=lista_eventos[i][1]
      senal_n.append(senal[num:num+7500])
      stages_n.append(lista_stages[i])
  
  #print(senal_n[134])

  lista_RR=[]
  for i in range(len(senal_n)):
    #deteccion_r = processing.xqrs_detect(senal_n[i], fs)
    deteccion_r = panytom(senal_n[i], fs)
    lista_RR_seg = []
    for j in range (0 , len(deteccion_r)-1):
      lista_RR_seg.append([np.abs(deteccion_r[j+1]-deteccion_r[j]), deteccion_r[j]]) #Devuelve en el primer valor la cantidad de muestras en el intervalo, y en el segundo la posicion donde arranca el intervalo RR
    lista_RR.append(lista_RR_seg)
  
  lista_RR[134]=lista_RR[133]
  NN = []
  senal_limpia = []
  for i in range(len(senal_n)):
    media, desvio, RMSSD = estimadores(lista_RR[i])
    N = len(lista_RR[i])
    NN_seg = []
    senal_limpia_seg = []
    for j in range(0, N):
      if 0.7*media <= lista_RR[i][j][0] and lista_RR[i][j][0] <= 1.3*media and lista_RR[i][j][0] >= (media-3*desvio) and lista_RR[i][j][0] <= (media+3*desvio):
        senal_limpia_seg.extend(senal[lista_RR[i][j][1]:lista_RR[i][j][1]+lista_RR[i][j][0]])
        NN_seg.append(lista_RR[i][j])
    NN.append(NN_seg)
    senal_limpia.append(senal_limpia_seg)
  
  return eventos_n, stages_n, senal_limpia, NN

eventos1, stages1, senal_ecg1, NN_1 =     procesamiento(path1, senal_ecg1, fs)
eventos2, stages2, senal_ecg2, NN_2 =     procesamiento(path2, senal_ecg2, fs)
eventos3, stages3, senal_ecg3, NN_3 =     procesamiento(path3, senal_ecg3, fs)
eventos4, stages4, senal_ecg4, NN_4 =     procesamiento(path4, senal_ecg4, fs)
eventos5, stages5, senal_ecg5, NN_5 =     procesamiento(path5, senal_ecg5, fs)
eventos6, stages6, senal_ecg6, NN_6 =     procesamiento(path6, senal_ecg6, fs)
eventos7, stages7, senal_ecg7, NN_7 =     procesamiento(path7, senal_ecg7, fs)
eventos8, stages8, senal_ecg8, NN_8 =     procesamiento(path8, senal_ecg8, fs)
eventos9, stages9, senal_ecg9, NN_9 =     procesamiento(path9, senal_ecg9, fs)
'''
eventos10, stages10, senal_ecg10, NN_10 = procesamiento(path10, senal_ecg10, fs)
eventos11, stages11, senal_ecg11, NN_11 = procesamiento(path11, senal_ecg11, fs)
eventos12, stages12, senal_ecg12, NN_12 = procesamiento(path12, senal_ecg12, fs)
eventos13, stages13, senal_ecg13, NN_13 = procesamiento(path13, senal_ecg13, fs)
eventos14, stages14, senal_ecg14, NN_14 = procesamiento(path14, senal_ecg14, fs)
eventos15, stages15, senal_ecg15, NN_15 = procesamiento(path15, senal_ecg15, fs)
eventos16, stages16, senal_ecg16, NN_16 = procesamiento(path16, senal_ecg16, fs)
eventos17, stages17, senal_ecg17, NN_17 = procesamiento(path17, senal_ecg17, fs)
eventos18, stages18, senal_ecg18, NN_18 = procesamiento(path18, senal_ecg18, fs)
'''

def DEP (posiciones, fs):
  NN = pyhrv.tools.nn_intervals(posiciones)
  plt.ioff()
  welch = pyhrv.frequency_domain.welch_psd(NN, posiciones//fs, show = False, show_param = False)
  plt.close()
  plt.ioff()
  lomb = pyhrv.frequency_domain.lomb_psd(NN, posiciones//fs, show =False, show_param=False)
  plt.close()
  plt.ioff()
  ar =  pyhrv.frequency_domain.ar_psd(NN, posiciones//fs, show =False, show_param =False)
  plt.close()
  VLF_fft = welch['fft_abs'][0]
  LF_fft = welch['fft_abs'][1]
  HF_fft = welch['fft_abs'][2]

  VLF_lomb = lomb['lomb_abs'][0]
  LF_lomb = lomb['lomb_abs'][1]
  HF_lomb = lomb['lomb_abs'][2]

  VLF_ar = ar['ar_abs'][0]
  LF_ar = ar['ar_abs'][1]
  HF_ar = ar['ar_abs'][2]

  division_fft = LF_fft/HF_fft
  LFn_fft = (LF_fft*100)/(LF_fft + HF_fft - VLF_fft)
  HFn_fft = (HF_fft*100) / (LF_fft + HF_fft - VLF_fft)

  lista_fft = [division_fft, LFn_fft, HFn_fft]

  division_lomb = LF_lomb/HF_lomb
  LFn_lomb = (LF_lomb*100)/(LF_lomb + HF_lomb - VLF_lomb)
  HFn_lomb = (HF_lomb*100) / (LF_lomb + HF_lomb - VLF_lomb)

  lista_lomb = [division_lomb, LFn_lomb, HFn_lomb]

  division_ar = LF_ar/HF_ar
  LFn_ar = (LF_ar*100)/(LF_ar + HF_ar - VLF_ar)
  HFn_ar = (HF_ar*100) / (LF_ar + HF_ar - VLF_ar)

  lista_ar = [division_ar, LFn_ar, HFn_ar]

  lista = [lista_fft, lista_lomb, lista_ar]

  return lista

def caracteristicas (NN, fs):
  carac_frecuencia = []
  carac_tiempo = []

  for i in range(len(NN)):
    NN[i] = np.asarray(NN[i])
    posiciones = NN[i][:,1]

    carac_frecuencia_seg = DEP(posiciones, fs)
    carac_frecuencia.append(carac_frecuencia_seg)

  for i in range(len(NN)):
    media, desvio, RMSSD = estimadores(NN[i])
    carac_tiempo_seg = [media, desvio, RMSSD]
    carac_tiempo.append(carac_tiempo_seg)
  
  return carac_tiempo, carac_frecuencia

"""# ESCONDO"""

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# def apnea (path):
#   anotaciones_sueno= wfdb.rdann(path,'st',1)
#   anot=anotaciones_sueno.aux_note
#   sam=anotaciones_sueno.sample
#   cadena=0
#   lista_eventos=[]
#   lista_stages=[]
# 
#   for j in range (0, len(anot)):
#     cadena= str(anot[j])
#     lista_eventos.append([cadena[2:4],sam[j]])
#     lista_stages.append(cadena[0:2])
# 
#   return lista_eventos
# 
# fun= apnea(path1)
# print(apnea(path3))
# print(len(apnea(path3)))
#

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# anotaciones_sueno= wfdb.rdann(path3,'st',1)
# anot=anotaciones_sueno.aux_note
# print(anot)
#

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# 
# def eventos(path):
#   anotaciones_sueno= wfdb.rdann(path,'st',1)
#   anot=anotaciones_sueno.aux_note
#   sam=anotaciones_sueno.sample
#   cadena=0
# 
#   lista_eventos=[]
#   for j in range (0, len(anot)):
#     cadena= str(anot[j])
#     lista_eventos.append([cadena[2:4],sam[j]])
#   
#   return lista_eventos

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# 
# def stages(path):
#   anotaciones_sueno= wfdb.rdann(path,'st',1)
#   anot=anotaciones_sueno.aux_note
#   sam=anotaciones_sueno.sample
#   cadena=0
# 
#   lista_stages=[]
#   for j in range (0, len(anot)):
#     cadena= str(anot[j])
#     if cadena[0:1] not in ('OA','CAA','C', 'X', 'M','LA','L','H','A', 'O'):
#       lista_stages.append(cadena[0:1])
#   
#   return lista_stages
# 
# senal_eeg1 = stages(path1)
# senal_eeg2 = stages(path2)
# senal_eeg3 = stages(path3)
# senal_eeg4 = stages(path4)
# senal_eeg5 = stages(path5)
# senal_eeg6 = stages(path6)
# senal_eeg7 = stages(path7)
# senal_eeg8 = stages(path8)
# senal_eeg9 = stages(path9)
# senal_eeg10 = stages(path10)
# senal_eeg11 = stages(path11)
# senal_eeg12 = stages(path12)
# senal_eeg13 = stages(path13)
# senal_eeg14 = stages(path14)
# senal_eeg15 = stages(path15)
# senal_eeg16 = stages(path16)
# senal_eeg17 = stages(path17)
# senal_eeg18 = stages(path18)
# 
# print(len(senal_eeg3))

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# 
# def eliminar_apnea(lista_stages,lista_eventos,senal):
#   senal_n=[]
#   stages_n=[]
#   print(len(lista_eventos), len(lista_stages))
#   for i in range (0, len (lista_eventos)):
#     if lista_eventos[i][0] not in ('OA','CAA','CA', 'X', 'MT'): #DEJAMOS LAS H Y HA
#       num=lista_eventos[i][1]
#       senal_n.extend(senal[num:num+7499])
# 
#       stages_n.append(lista_stages[i-1])
# 
#   senal_n= np.array(senal_n)
#   
#   return senal_n, stages_n

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# 
# even1= eventos(path1)
# even2= eventos(path2)
# even3= eventos(path3)
# even4= eventos(path4)
# even5= eventos(path5)
# even6= eventos(path6)
# even7= eventos(path7)
# even8= eventos(path8)
# even9= eventos(path9)
# even10= eventos(path10)
# even11= eventos(path11)
# even12= eventos(path12)
# even13= eventos(path13)
# even14= eventos(path14)
# even15= eventos(path15)
# even16= eventos(path16)
# even17= eventos(path17)
# even18= eventos(path18)
# 
# senal_ecg1, senal_eeg1= eliminar_apnea(senal_eeg1,even1,senal_ecg1)
# senal_ecg2, senal_eeg2= eliminar_apnea(senal_eeg2,even2,senal_ecg2)
# senal_ecg3, senal_eeg3= eliminar_apnea(senal_eeg3,even3,senal_ecg3)
# senal_ecg4, senal_eeg4= eliminar_apnea(senal_eeg4,even4,senal_ecg4)
# senal_ecg5, senal_eeg5= eliminar_apnea(senal_eeg5,even5,senal_ecg5)
# senal_ecg6, senal_eeg6= eliminar_apnea(senal_eeg6,even6,senal_ecg6)
# senal_ecg7, senal_eeg7= eliminar_apnea(senal_eeg7,even7,senal_ecg7)
# senal_ecg8, senal_eeg8= eliminar_apnea(senal_eeg8,even8,senal_ecg8)
# senal_ecg9, senal_eeg9= eliminar_apnea(senal_eeg9,even9,senal_ecg9)
# senal_ecg10, senal_eeg10= eliminar_apnea(senal_eeg10,even10,senal_ecg10)
# senal_ecg11, senal_eeg12= eliminar_apnea(senal_eeg11,even11,senal_ecg11)
# senal_ecg12, senal_eeg11= eliminar_apnea(senal_eeg12,even12,senal_ecg12)
# senal_ecg13, senal_eeg13= eliminar_apnea(senal_eeg13,even13,senal_ecg13)
# senal_ecg14, senal_eeg14= eliminar_apnea(senal_eeg14,even14,senal_ecg14)
# senal_ecg15, senal_eeg15= eliminar_apnea(senal_eeg15,even15,senal_ecg15)
# senal_ecg16, senal_eeg16= eliminar_apnea(senal_eeg16,even16,senal_ecg16)
# senal_ecg17, senal_eeg17= eliminar_apnea(senal_eeg17,even17,senal_ecg17)
# print(len(senal_eeg3))
# senal_ecg18, senal_eeg18= eliminar_apnea(senal_eeg18,even18,senal_ecg18)

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# 
# def intervalo_RR(ecg):
#   deteccion_r = processing.xqrs_detect(ecg, fs)
#   lista_intervalos=[]
#   for i in range (0 , len(deteccion_r)-1):
#     lista_intervalos.append([np.abs(deteccion_r[i+1]-deteccion_r[i]), deteccion_r[i]]) #Devuelve en el primer valor la cantidad de muestras en el intervalo, y en el segundo la posicion donde arranca el intervalo RR
#   #media_intervalo= np.mean(lista_intervalos)
#   #print(f"la media del intervalo es: {np.round(media_intervalo *1000,3)} ms")
#   return lista_intervalos
#

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# 
# RR_1= intervalo_RR(senal_ecg1)
# RR_2= intervalo_RR(senal_ecg2)
# RR_3= intervalo_RR(senal_ecg3)
# RR_4= intervalo_RR(senal_ecg4)
# RR_5= intervalo_RR(senal_ecg5)
# RR_6= intervalo_RR(senal_ecg6)
# RR_7= intervalo_RR(senal_ecg7)
# RR_8= intervalo_RR(senal_ecg8)
# RR_9= intervalo_RR(senal_ecg9)
# RR_10= intervalo_RR(senal_ecg10)
# RR_11= intervalo_RR(senal_ecg11)
# RR_12= intervalo_RR(senal_ecg12)
# RR_13= intervalo_RR(senal_ecg13)
# RR_14= intervalo_RR(senal_ecg14)
# RR_15= intervalo_RR(senal_ecg15)
# RR_16= intervalo_RR(senal_ecg16)
# RR_17= intervalo_RR(senal_ecg17)
# RR_18= intervalo_RR(senal_ecg18)

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# 
# print(len(RR_18))

"""

Calculo de los estimadores de la señal: 
*   Media 
*   Desvio Estandar 
*   La raiz cuadrada de la media sucesiva entre ciclos normales y adyacentes
"""

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# 
# def estimadores(lista_intervalos):
#   media=0
#   desvio=0
#   RMSSD=0
#   N=len(lista_intervalos)
# 
#   for j in range(0, N):
#     media+=lista_intervalos[j][0]
#   media=media/N
# 
#   for i in range(0,N):
#     desvio+=(lista_intervalos[i][0]-media)**2
#   desvio=np.sqrt(desvio/N)
# 
#   for k in range(0,N-1):
#     RMSSD+= (lista_intervalos[k+1][0]-lista_intervalos[k][0])**2
#   RMSSD= np.sqrt(RMSSD/N)
# 
#   return media, desvio, RMSSD

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# 
# media1, desvio1, RMSSD1 = estimadores(RR_1)
# media2, desvio2, RMSSD2 = estimadores(RR_2)
# media3, desvio3, RMSSD3 = estimadores(RR_3)
# media4, desvio4, RMSSD4 = estimadores(RR_4)
# media5, desvio5, RMSSD5 = estimadores(RR_5)
# media6, desvio6, RMSSD6 = estimadores(RR_6)
# media7, desvio7, RMSSD7 = estimadores(RR_7)
# media8, desvio8, RMSSD8 = estimadores(RR_8)
# media9, desvio9, RMSSD9 = estimadores(RR_9)
# media10, desvio10, RMSSD10 = estimadores(RR_10)
# media11, desvio11, RMSSD11 = estimadores(RR_11)
# media12, desvio12, RMSSD12 = estimadores(RR_12)
# media13, desvio13, RMSSD13 = estimadores(RR_13)
# media14, desvio14, RMSSD14 = estimadores(RR_14)
# media15, desvio15, RMSSD15 = estimadores(RR_15)
# media16, desvio16, RMSSD16 = estimadores(RR_16)
# media17, desvio17, RMSSD17 = estimadores(RR_17)
# media18, desvio18, RMSSD18 = estimadores(RR_18)

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# 
# def preproc(senal, media, desvio, RR):
#   senal_limpia = []
#   NN = []
#   N = len(RR)
#   for i in range(0, N):
#     if 0.7*media <= RR[i][0] and RR[i][0] <= 1.3*media and RR[i][0] >= (media-3*desvio) and RR[i][0] <= (media+3*desvio):
#       senal_limpia.extend(senal[RR[i][1]:RR[i][1]+RR[i][0]])
#       NN.append(RR[i])
#    
#   puntos=len(NN)/50
#   y=[]
# 
#   for i in range(int(puntos)):
#     y.append(NN[int(i*50)])
# 
#   # NN = np.array(NN)
#   # NN = NN//50
# 
#   #1. muestreamos la señal --> tambien hay que muestrear los intervalos
#   #2. si eliminamos y muestreamos la señal ecg --> tambien habria que hacerlo con la señal eeg
#   
#   return senal_limpia, NN #era senal, RR

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# 
# senal_ecg_limpia1, NN_1 = preproc(senal_ecg1, media1, desvio1, RR_1)
# senal_ecg_limpia2, NN_2 = preproc(senal_ecg2, media2, desvio2, RR_2)
# senal_ecg_limpia3, NN_3 = preproc(senal_ecg3, media3, desvio3, RR_3)
# senal_ecg_limpia4, NN_4 = preproc(senal_ecg4, media4, desvio4, RR_4)
# senal_ecg_limpia5, NN_5 = preproc(senal_ecg5, media5, desvio5, RR_5)
# senal_ecg_limpia6, NN_6 = preproc(senal_ecg6, media6, desvio6, RR_6)
# senal_ecg_limpia7, NN_7 = preproc(senal_ecg7, media7, desvio7, RR_7)
# senal_ecg_limpia8, NN_8 = preproc(senal_ecg8, media8, desvio8, RR_8)
# senal_ecg_limpia9, NN_9 = preproc(senal_ecg9, media9, desvio9, RR_9)
# senal_ecg_limpia10, NN_10 = preproc(senal_ecg10, media10, desvio10, RR_10)
# senal_ecg_limpia11, NN_11 = preproc(senal_ecg11, media11, desvio11, RR_11)
# senal_ecg_limpia12, NN_12 = preproc(senal_ecg12, media12, desvio12, RR_12)
# senal_ecg_limpia13, NN_13 = preproc(senal_ecg13, media13, desvio13, RR_13)
# senal_ecg_limpia14, NN_14 = preproc(senal_ecg14, media14, desvio14, RR_14)
# senal_ecg_limpia15, NN_15 = preproc(senal_ecg15, media15, desvio15, RR_15)
# senal_ecg_limpia16, NN_16 = preproc(senal_ecg16, media16, desvio16, RR_16)
# senal_ecg_limpia17, NN_17 = preproc(senal_ecg17, media17, desvio17, RR_17)
# senal_ecg_limpia18, NN_18 = preproc(senal_ecg18, media18, desvio18, RR_18)
#

"""PARTE CON LAS DENSIDADES ESPECTRALES DE LAS SEÑALES


*   DEP c/ fft
*   AR
*   Periodograma de Lomb




"""

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# 
# #CON LA TRANSFORMADA RAPIDA DE FOURIER 
# 
# def DEP_fourier(i_NN,fs):
#   # transformada= fft(i_NN)
#   # dep= np.abs(transformada)**2 / (fs*len(i_NN))
# 
#   welch = pyhrv.frequency_domain.welch_psd(i_NN[:,0]//fs, i_NN[:,1]//fs, show = False, show_param = False)
#   abs0 = welch['fft_abs']
# 
#   return abs0
# 
# #CON EL PERIODOGRAMA DE LOMB
# 
# def lomb(i_NN,fs):
#   lomb= pyhrv.frequency_domain.lomb_psd(i_NN[:,0]//fs,i_NN[:,1]//fs, show =False, show_param=False)
#   abs=lomb['lomb_abs']
# 
#   return abs
# 
# #Modelo AR
# 
# def DEP_ar (i_NN, fs):
#   ar =  pyhrv.frequency_domain.ar_psd(i_NN[:,0]//fs,i_NN[:,1]//fs, show =False, show_param =False)
#   abs1 = ar['ar_abs']
#   
#   return abs1
#

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# 
# #fs=5
# 
# NN_1 = np.array(NN_1)
# NN_2 = np.array(NN_2)
# NN_3 = np.array(NN_3)
# NN_4 = np.array(NN_4)
# NN_5 = np.array(NN_5)
# NN_6 = np.array(NN_6)
# NN_7 = np.array(NN_7)
# NN_8 = np.array(NN_8)
# NN_9 = np.array(NN_9)
# NN_10 = np.array(NN_10)
# NN_11 = np.array(NN_11)
# NN_12 = np.array(NN_12)
# NN_13 = np.array(NN_13)
# NN_14 = np.array(NN_14)
# NN_15 = np.array(NN_15)
# NN_16 = np.array(NN_16)
# NN_17 = np.array(NN_17)
# NN_18 = np.array(NN_18)
# 
# transformada1 = DEP_fourier(NN_1,fs)
# transformada2 = DEP_fourier(NN_2,fs)
# transformada3 = DEP_fourier(NN_3,fs)
# transformada4 = DEP_fourier(NN_4,fs)
# transformada5 = DEP_fourier(NN_5,fs)
# transformada6 = DEP_fourier(NN_6,fs)
# transformada7 = DEP_fourier(NN_7,fs)
# transformada8 = DEP_fourier(NN_8,fs)
# transformada9 = DEP_fourier(NN_9,fs)
# transformada10 = DEP_fourier(NN_10,fs)
# transformada11 = DEP_fourier(NN_11,fs)
# transformada12 = DEP_fourier(NN_12,fs)
# transformada13 = DEP_fourier(NN_13,fs)
# transformada14 = DEP_fourier(NN_14,fs)
# transformada15 = DEP_fourier(NN_15,fs)
# transformada16 = DEP_fourier(NN_16,fs)
# transformada17 = DEP_fourier(NN_17,fs)
# transformada18 = DEP_fourier(NN_18,fs)
#

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# 
# lomb_1=lomb(NN_1,fs)
# lomb_2=lomb(NN_2,fs)
# lomb_3=lomb(NN_3,fs)
# lomb_4=lomb(NN_4,fs)
# lomb_5=lomb(NN_5,fs)
# lomb_6=lomb(NN_6,fs)
# lomb_7=lomb(NN_7,fs)
# lomb_8=lomb(NN_8,fs)
# lomb_9=lomb(NN_9,fs)
# lomb_10=lomb(NN_10,fs)
# lomb_11=lomb(NN_11,fs)
# lomb_12=lomb(NN_12,fs)
# lomb_13=lomb(NN_13,fs)
# lomb_14=lomb(NN_14,fs)
# lomb_15=lomb(NN_15,fs)
# lomb_16=lomb(NN_16,fs)
# lomb_17=lomb(NN_17,fs)
# lomb_18=lomb(NN_18,fs)
#

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# 
# ar_1 = DEP_ar (NN_1,fs)
# ar_2 = DEP_ar (NN_2,fs)
# ar_3 = DEP_ar (NN_3,fs)
# ar_4 = DEP_ar (NN_4,fs)
# ar_5 = DEP_ar (NN_5,fs)
# ar_6 = DEP_ar (NN_6,fs)
# ar_7 = DEP_ar (NN_7,fs)
# ar_8 = DEP_ar (NN_8,fs)
# ar_9 = DEP_ar (NN_9,fs)
# ar_10 = DEP_ar (NN_10,fs)
# ar_11 = DEP_ar (NN_11,fs)
# ar_12 = DEP_ar (NN_12,fs)
# ar_13 = DEP_ar (NN_13,fs)
# ar_14 = DEP_ar (NN_14,fs)
# ar_15 = DEP_ar (NN_15,fs)
# ar_16 = DEP_ar (NN_16,fs)
# ar_17 = DEP_ar (NN_17,fs)
# ar_18 = DEP_ar (NN_18,fs)
#

"""# DESESCONDO

---- MACHINE LEARNING ----
"""

tiempo = []
frec = []
cont = 0

#intervalos = [NN_1, NN_2, NN_3, NN_4, NN_5, NN_6, NN_7, NN_8, NN_9, NN_10, NN_11, NN_12, NN_13, NN_14, NN_15, NN_16, NN_17, NN_18]
intervalos = [NN_1, NN_2, NN_3, NN_4, NN_5, NN_6, NN_7, NN_8, NN_9]
for i in range(9): #deberia ser 18!!!
  cont += 1
  tiempo_senal, frec_senal = caracteristicas (intervalos[i], fs) #deberia ser intervalos[i], fs !!!!
  tiempo.append(tiempo_senal)
  frec.append(frec_senal)

print(tiempo)

todo_tiempo = np.array(tiempo)
todo_frec = np.array(frec)

print(todo_tiempo)

#DICCIONARIO 
diccionario = {
              'slp01a': { 'N_senal': 1,'Media': 0, 'Desvio': 0, 'RMSSD': 0, 'LF/HF FFT': 0, 'LFn FFT': 0, 'HFn FFT': 0, 'LF/HF lomb': 0, 'LFn lomb': 0, 'HFn lomb': 0, 'LF/HF AR': 0, 'LFn AR': 0, 'HFn AR': 0, 'EEG': []},
              'slp01b': { 'N_senal': 2,'Media': 0, 'Desvio': 0, 'RMSSD': 0, 'LF/HF FFT': 0, 'LFn FFT': 0, 'HFn FFT': 0, 'LF/HF lomb': 0, 'LFn lomb': 0, 'HFn lomb': 0, 'LF/HF AR': 0, 'LFn AR': 0, 'HFn AR': 0, 'EEG': []},
              'slp02a': { 'N_senal': 3,'Media': 0, 'Desvio': 0, 'RMSSD': 0, 'LF/HF FFT': 0, 'LFn FFT': 0, 'HFn FFT': 0, 'LF/HF lomb': 0, 'LFn lomb': 0, 'HFn lomb': 0, 'LF/HF AR': 0, 'LFn AR': 0, 'HFn AR': 0, 'EEG': []},
              'slp02b': { 'N_senal': 4,'Media': 0, 'Desvio': 0, 'RMSSD': 0, 'LF/HF FFT': 0, 'LFn FFT': 0, 'HFn FFT': 0, 'LF/HF lomb': 0, 'LFn lomb': 0, 'HFn lomb': 0, 'LF/HF AR': 0, 'LFn AR': 0, 'HFn AR': 0, 'EEG': []},
              'slp03' : { 'N_senal': 5,'Media': 0, 'Desvio': 0, 'RMSSD': 0, 'LF/HF FFT': 0, 'LFn FFT': 0, 'HFn FFT': 0, 'LF/HF lomb': 0, 'LFn lomb': 0, 'HFn lomb': 0, 'LF/HF AR': 0, 'LFn AR': 0, 'HFn AR': 0, 'EEG': []},
              'slp04' : { 'N_senal': 6,'Media': 0, 'Desvio': 0, 'RMSSD': 0, 'LF/HF FFT': 0, 'LFn FFT': 0, 'HFn FFT': 0, 'LF/HF lomb': 0, 'LFn lomb': 0, 'HFn lomb': 0, 'LF/HF AR': 0, 'LFn AR': 0, 'HFn AR': 0, 'EEG': []},
              'slp14' : { 'N_senal': 7,'Media': 0, 'Desvio': 0, 'RMSSD': 0, 'LF/HF FFT': 0, 'LFn FFT': 0, 'HFn FFT': 0, 'LF/HF lomb': 0, 'LFn lomb': 0, 'HFn lomb': 0, 'LF/HF AR': 0, 'LFn AR': 0, 'HFn AR': 0, 'EEG': []},
              'slp16' : { 'N_senal': 8,'Media': 0, 'Desvio': 0, 'RMSSD': 0, 'LF/HF FFT': 0, 'LFn FFT': 0, 'HFn FFT': 0, 'LF/HF lomb': 0, 'LFn lomb': 0, 'HFn lomb': 0, 'LF/HF AR': 0, 'LFn AR': 0, 'HFn AR': 0, 'EEG': []},
              'slp32' : { 'N_senal': 9,'Media': 0, 'Desvio': 0, 'RMSSD': 0, 'LF/HF FFT': 0, 'LFn FFT': 0, 'HFn FFT': 0, 'LF/HF lomb': 0, 'LFn lomb': 0, 'HFn lomb': 0, 'LF/HF AR': 0, 'LFn AR': 0, 'HFn AR': 0, 'EEG': []},
              'slp37' : { 'N_senal': 10,'Media': 0, 'Desvio': 0, 'RMSSD': 0, 'LF/HF FFT': 0, 'LFn FFT': 0, 'HFn FFT': 0, 'LF/HF lomb': 0, 'LFn lomb': 0, 'HFn lomb': 0, 'LF/HF AR': 0, 'LFn AR': 0, 'HFn AR': 0, 'EEG': []},
              'slp41' : { 'N_senal': 11,'Media': 0, 'Desvio': 0, 'RMSSD': 0, 'LF/HF FFT': 0, 'LFn FFT': 0, 'HFn FFT': 0, 'LF/HF lomb': 0, 'LFn lomb': 0, 'HFn lomb': 0, 'LF/HF AR': 0, 'LFn AR': 0, 'HFn AR': 0, 'EEG': []},
              'slp45' : { 'N_senal': 12,'Media': 0, 'Desvio': 0, 'RMSSD': 0, 'LF/HF FFT': 0, 'LFn FFT': 0, 'HFn FFT': 0, 'LF/HF lomb': 0, 'LFn lomb': 0, 'HFn lomb': 0, 'LF/HF AR': 0, 'LFn AR': 0, 'HFn AR': 0, 'EEG': []},
              'slp48' : { 'N_senal': 13,'Media': 0, 'Desvio': 0, 'RMSSD': 0, 'LF/HF FFT': 0, 'LFn FFT': 0, 'HFn FFT': 0, 'LF/HF lomb': 0, 'LFn lomb': 0, 'HFn lomb': 0, 'LF/HF AR': 0, 'LFn AR': 0, 'HFn AR': 0, 'EEG': []},
              'slp59' : { 'N_senal': 14,'Media': 0, 'Desvio': 0, 'RMSSD': 0, 'LF/HF FFT': 0, 'LFn FFT': 0, 'HFn FFT': 0, 'LF/HF lomb': 0, 'LFn lomb': 0, 'HFn lomb': 0, 'LF/HF AR': 0, 'LFn AR': 0, 'HFn AR': 0, 'EEG': []},
              'slp60' : { 'N_senal': 15,'Media': 0, 'Desvio': 0, 'RMSSD': 0, 'LF/HF FFT': 0, 'LFn FFT': 0, 'HFn FFT': 0, 'LF/HF lomb': 0, 'LFn lomb': 0, 'HFn lomb': 0, 'LF/HF AR': 0, 'LFn AR': 0, 'HFn AR': 0, 'EEG': []},
              'slp61' : { 'N_senal': 16,'Media': 0, 'Desvio': 0, 'RMSSD': 0, 'LF/HF FFT': 0, 'LFn FFT': 0, 'HFn FFT': 0, 'LF/HF lomb': 0, 'LFn lomb': 0, 'HFn lomb': 0, 'LF/HF AR': 0, 'LFn AR': 0, 'HFn AR': 0, 'EEG': []},
              'slp66' : { 'N_senal': 17,'Media': 0, 'Desvio': 0, 'RMSSD': 0, 'LF/HF FFT': 0, 'LFn FFT': 0, 'HFn FFT': 0, 'LF/HF lomb': 0, 'LFn lomb': 0, 'HFn lomb': 0, 'LF/HF AR': 0, 'LFn AR': 0, 'HFn AR': 0, 'EEG': []},
              'slp67' : { 'N_senal': 18,'Media': 0, 'Desvio': 0, 'RMSSD': 0, 'LF/HF FFT': 0, 'LFn FFT': 0, 'HFn FFT': 0, 'LF/HF lomb': 0, 'LFn lomb': 0, 'HFn lomb': 0, 'LF/HF AR': 0, 'LFn AR': 0, 'HFn AR': 0, 'EEG': []},
               }

lista_senales = ['slp01a', 'slp01b', 'slp02a', 'slp02b','slp03','slp04','slp14','slp16','slp32','slp37','slp41','slp45','slp48','slp59','slp60','slp61','slp66','slp67']
lista_eeg = [stages1, stages2, stages3, stages4, stages5, stages6, stages7, stages8, stages9, stages10, stages11, stages12, stages13, stages14, stages15, stages16, stages17, stages18]


for k in range(0, len(lista_senales)):
  diccionario[lista_senales[k]]['Media'] = todo_tiempo[k][:,0]
  diccionario[lista_senales[k]]['Desvio'] = todo_tiempo[k][:,1]
  diccionario[lista_senales[k]]['RMSSD'] = todo_tiempo[k][:,2]
  diccionario[lista_senales[k]]['LF/HF FFT'] = todo_frec[k][:,0,0]
  diccionario[lista_senales[k]]['LFn FFT'] = todo_frec[k][:,0,1]
  diccionario[lista_senales[k]]['HFn FFT'] = todo_frec[k][:,0,2]

  diccionario[lista_senales[k]]['LF/HF lomb'] = todo_frec[k][:,1,0]
  diccionario[lista_senales[k]]['LFn lomb'] = todo_frec[k][:,1,1]
  diccionario[lista_senales[k]]['HFn lomb'] = todo_frec[k][:,1,2]

  diccionario[lista_senales[k]]['LF/HF AR'] = todo_frec[k][:,2,0]
  diccionario[lista_senales[k]]['LFn AR'] = todo_frec[k][:,2,1]
  diccionario[lista_senales[k]]['HFn AR'] = todo_frec[k][:,2,2]

  diccionario[lista_senales[k]]['EEG'] = lista_eeg[k]

df = pd.DataFrame.from_dict(diccionario)
df.columns = ['slp01a', 'slp01b','slp02a', 'slp02b', 'slp03', 'slp04', 'slp14', 'slp16', 'slp32','slp37', 'slp41', 'slp45', 'slp48', 'slp59', 'slp60', 'slp61', 'slp66', 'slp67']
df = df.T
df

"""Voy a randomizar el orden de las señales para que en cada entrenamiento o testeo vaya usando distintas señales y no entrene con las mismas. """

df.sample(frac=1.0)
df

#NOMBRO 3 DE TESTING Y 15 DE TRAINING 
df_testeo = df.iloc[14:17]
df_entrena = df.drop(df_testeo.index) #saco los que son de testeo, uso todos los que no son para la prueba

#HACEMOS DATAFRAMES DE ENTRAMIENTO PARA CADA METOOD FRECUENCIAL (lomb, AR, FFT)

df_entrena_fft = df_entrena.loc[:,df_entrena.columns.isin(['Media','Desvio','RMSSD', 'LF/HF FFT', 'LFn FFT', 'HFn FFT'])]
df_entrena_lomb = df_entrena.loc[:,df_entrena.columns.isin(['Media','Desvio','RMSSD', 'LF/HF lomb', 'LFn lomb', 'HFn lomb'])]
df_entrena_ar = df_entrena.loc[:,df_entrena.columns.isin(['Media','Desvio','RMSSD', 'LF/HF AR', 'LFn AR', 'HFn AR'])]

#PONGO EL TARGET QUE EN ESTE CASO ES EL EEG 

df_target = df_entrena.loc[:,df_entrena.columns.isin(['EEG'])]
df_target

"""*Decidimos utilizar el metodo de prediccion de k vecinos mas cercanos*, ya que las preddciones no son booleans si no que tiene que predecir un array con los estados del sueño, entonces tiene mas sentido utilizar este metodo que analiza los vecinos mas cercanos para cada estado. Convertimos la columna de EEG  a listas para que el clasificador me lo tome como valido."""

#lista_target = df_target.to_numpy()
#lista_target.tolist()
lista_target = []
for i in range(0,len(df_entrena)): 
  lista_target.append(df_target[0][i]) 

lista_target = np.array(lista_target)

print(np.shape(df_entrena))
print(np.shape(lista_target))

from sklearn.neighbors import KNeighborsClassifier
clf_kNN = KNeighborsClassifier(n_neighbors=3)
clf_kNN.fit( , )

clf_kNN.fit(df_entrena, lista_target)